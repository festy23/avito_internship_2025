# Architecture

## Обзор

Проект использует **Package Oriented Design (POD) с элементами Clean Architecture в формате модульного монолита**.

## Архитектура проекта

### Структура

- Модули по доменам: `team`, `user`, `pullrequest`
- Трехслойная архитектура внутри модуля: `handler` → `service` → `repository`
- Общие компоненты: `config`, `database`, `middleware`

### Слои

#### Handler

HTTP слой, обработка запросов и ответов. Использует Gin framework.

#### Service

Бизнес-логика, изолирована от HTTP и БД. Содержит основную логику работы с доменными сущностями.

#### Repository

Слой доступа к данным через GORM. Изолирован от бизнес-логики.

#### Model

Доменные модели данных. Определяют структуры сущностей (Team, User, PullRequest) и их валидацию.

## Выбор архитектуры

### Почему Package Oriented Design

- **Модульность** — каждый модуль самодостаточен и изолирован
- **Идиоматичный Go** — соответствует практикам Go сообщества
- **Простота навигации** — легко найти код по домену
- **Масштабируемость** — легко добавлять новые модули
- **Избежание overengineering** — не нужны лишние абстракции для простого проекта

### Почему модульный монолит

- **Простота** — один процесс, одна БД, проще разработка и отладка
- **Низкая нагрузка** — RPS 5 не требует распределенной системы
- **Малый объем данных** — до 200 пользователей не требует масштабирования
- **Быстрый запуск** — один docker-compose, один контейнер
- **Модульность** — код организован по доменам, легко поддерживать

### Почему трехслойная архитектура

- **Разделение ответственности** — каждый слой решает свою задачу
- **Тестируемость** — легко мокировать repository для тестов service
- **Гибкость** — можно менять БД или HTTP фреймворк без изменения бизнес-логики
- **Простота** — не нужны интерфейсы для каждого слоя

## Выбор базы данных

### PostgreSQL 12

Выбрана PostgreSQL 12 в качестве базы данных.

### Обоснование

#### PostgreSQL vs другие варианты

**PostgreSQL vs MySQL/MariaDB:**

- Более строгая типизация
- Расширенные возможности (JSON типы, массивы)
- Лучшая поддержка транзакций
- Стандарт для Go проектов

**PostgreSQL vs SQLite:**

- Многопользовательский доступ
- Лучшая производительность при конкурентном доступе
- Расширенные возможности

**PostgreSQL vs In-Memory:**

- Персистентность данных
- ACID транзакции
- Масштабируемость

**PostgreSQL vs NoSQL:**

- Реляционная модель идеально подходит для связей между сущностями
- Транзакции критичны для операций назначения ревьюверов
- Отличная поддержка через GORM

## Плюсы выбранной архитектуры

- Простая и понятная структура проекта
- Легкая навигация по коду
- Быстрая разработка без лишних абстракций
- Хорошая тестируемость бизнес-логики
- Возможность масштабирования при росте проекта
- Соответствие требованиям задания (избежание overengineering)

## Структура проекта

```txt
internal/
  team/
    handler.go      # HTTP handlers
    service.go      # Бизнес-логика
    repository.go   # Доступ к БД
    model.go        # Модели данных
  
  user/
    handler.go
    service.go
    repository.go
    model.go
  
  pullrequest/
    handler.go
    service.go
    repository.go
    model.go
  
  config/          # Конфигурация
  database/        # Подключение к БД
  middleware/      # HTTP middleware
```
